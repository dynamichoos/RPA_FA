# RPA(Robotic Process Automation) Program For MHE QD Team.
#
# Generated by HC Lee & SH Lim @ MHE
#
# Copyright Limited <hclee@mandohella.com>
#                   <seonghyu.lim@mandohella.com>
#                   
# Generated @ 2021.Jan.15th ~ 
#

## Ver1.1 (~21.12.08) ##
## - config를 별도의 파일로 구성하고, 폴더는 상대주소 형태로 하위 폴더 형태로 구성
## - refactoring 수행하여 버그 수정하고, 함수 간의 종속성 최소화
## - Generation 간의 구분 block화

## 1. Gen2.0/Gen2.5와 Gen3.0의 ToolBrake 구분하여 개별 실행
## 2. 개별 프로그램에 대해서 ID 잡고 필요시에 foreground를 변경하며 사용 (추후 필요 시)
## 3. Gen3.0의 경우는 차종별로 상이하게 DTC와 Internal 상이함
##     => 차종별 그룹에 대해서 구분하여 sheet를 생성할지와 아니면 경우에 따라 구분하여 sheet를 나눠서 설정할지 결정??
##       => 기존 컨샙 사용하되, sheet 상에서 group을 결정하는 형태로 수행
##     => Tool brake 상에서는 차종별 그룹에 따라서 이동하며 클릭하여 창 pop-up 시킴 (추푸 필요 시)
##       => 측정 시, 케이블을 변경해야할 정도 인데 의미가 있을지???
##     => 차종별 그룹에 기준으로 internal Error map 생성 필요 (기존 문서 상에서 2개 생성하고, 1개에 대해서는 추가 추출하여 작성)
##       => 시트명에 대해서는 어떻게 하는게 좋을지???

import sys
import warnings
#from PyQt5.sip import voidptr
import numpy as np
import pyperclip3 as pc

warnings.simplefilter("ignore", UserWarning)
sys.coinit_flags = 2
#sys.setrecursionlimit(10000)  ##재귀함수 재한수 풀어줌

import os
import pandas as pd
import re           ## https://nachwon.github.io/regular-expressions/ ##
import openpyxl

#from datetime import datetime ##@@ datetime.datetime (import) to attach date on filename

from os.path import isfile, join
from os.path import *
from os import listdir
from PyQt5.QtWidgets import *
from PyQt5.QtCore import QCoreApplication, Qt
from PyQt5.QtGui import *
from openpyxl import load_workbook
#from openpyxl import Workbook
#from PIL import Image
from PIL import ImageGrab
from pywinauto.application import Application
import time
import win32gui, win32api, win32con
from win32com import client
import qd_event
import traceback
from pynput import mouse



##@@ Libraries for Email & Web ####

#import requests
#from bs4 import BeautifulSoup
#from selenium import webdriver
#from webdriver_manager.chrome import ChromeDriverManager   ## to match correct driver version

########################################

# 입/출력 문서 관리 폴더를 정의합니다.

config_name = r'.\config\overall_config.xlsx'

df_config = pd.read_excel(config_name, sheet_name='Total', engine='openpyxl')
df_config.set_index('list_name', inplace=True)

for list_name in df_config.index.to_list():
    
    varname = list_name
    locals()[varname] = df_config.loc[list_name,'path2']
    print(f'{list_name} = {locals()[varname]}')

print('in_in')
print(FA_list_name)


###########################
# result_path = r'D:/RPA_FA/result/'                    # 결과가 저장되는 폴더
# captured_image_path = r'D:/RPA_FA/result/captured_image/'    ##@@ 찾고자 하는 '직접 캡쳐한' 그림파일이 들어있는 폴더

# template_path = r'D:/RPA_FA/template/'

# FA_list_path = r'D:/RPA_FA/FA_list/'
# FA_list_name = r'D:/RPA_FA/FA_list/LGIT_정기고품 List_1029.xlsx'                      # FA List path

# diagnostic_list_name = r'D:/RPA_FA/config/diagnostic_list/get_diagnostics.xlsx'
# DTC_list_name = r'D:/RPA_FA/config/DTC_list/DTC_list.xlsx'
# internal_error_list_name = r'D:/RPA_FA/config/Internal_error_list/CAN_internal_error_map.xlsx'
###########################


class MyWindow(QWidget):

    pic_name_find1 = "{}.png".format(os.getpid())
    pic_name_find2 = "{}.png".format(os.getpid())
    shell = client.Dispatch("WScript.Shell")
    step = 0

    adobe_reader = Application(backend="uia")
    mspaint = Application(backend="win32")

    def __init__(self):
        super().__init__()
        self.setupUI()

        self.template_path = template_path
        self.FA_list_name = FA_list_name
        self.fixed_FA_report_template = ''


        #self.captured_image_path = captured_image_path
        self.DTC_list_name = DTC_list_name
        self.diagnostic_list_name = diagnostic_list_name
        self.internal_error_list_name = internal_error_list_name
  
    def setupUI(self):


        # 전체 Layout은 Grid 형태 입니다.
        QToolTip.setFont(QFont('sansSerif',10))
        layout = QGridLayout()
        self.myMenuBar = QMenuBar(self)
        self.myMenuBar.setFixedHeight(25)
        self.myMenuBar.setNativeMenuBar(False)
        self.myMenuBar.palette().setColor(self.myMenuBar.foregroundRole(), Qt.gray)
        self.file_menubar = self.myMenuBar.addMenu("&File")
        self.edit_menubar = self.myMenuBar.addMenu("Edit")
        self.view_menubar = self.myMenuBar.addMenu("view")
        self.environment_menubar = self.myMenuBar.addMenu("Environment")
        self.help_menubar = self.myMenuBar.addMenu("Help")
        self.file_menubar.addAction("New")
        self.file_menubar.addAction("Open")
        self.file_menubar.addAction("Close")
        self.file_menubar.addAction("Exit")
        self.view_menubar.addAction("Full_Screen")
        self.environment_menubar.addAction("Acrobat")
        self.environment_menubar.addAction("Mspaint")
        self.help_menubar.addAction("Program Info.")
        layout.addWidget(self.myMenuBar,0,0,1,5)

        #         self.프로젝트정보_그룹.setStyleSheet('QGroupBox:title {'
        #          'color: blue;'
        #          'background-color: red;'
        #          'subcontrol-position: top center;'
        #          'padding-left: 50px; padding-right: 50px; }')
        # self.프로젝트정보_그룹.setFont(QFont("맑은 고딕", 15, QFont.Bold))
        
        # 중간과정 문자표시 테이블
        # 디버깅 또는 중간과정을 사용자에게 전달하기 위해 만든 Text 창 그룹 입니다.
        self.terminal_group = QGroupBox('TERMINAL')
        # self.terminal_group.setStyleSheet("color: white;"
        #                                 "background-color: #3c3835;")
        self.terminal_layout = QVBoxLayout()
        self.terminal_browser = QTextBrowser()
        self.terminal_browser.setAcceptRichText(True)
        self.terminal_browser.setOpenExternalLinks(True)
        #self.terminal_browser.setFixedWidth(650)
        self.terminal_layout.addWidget(self.terminal_browser)
        self.terminal_group.setLayout(self.terminal_layout)
        layout.addWidget(self.terminal_group, 7,0,7,1)

        # function buttons
        # 각종 기능 버튼이 있는 그룹입니다. (Clear/Quit/Add row/Delete Row/Update Row 등등...)
        # 또 뭔가 기능을 넣을 때는 해당 그룹을 손되시면 됩니다. 크기도 좀 키워야 하는데...
        self.func_button_group = QGroupBox('TERMINAL_CONTROL_BUTTONS')
        # self.func_button_group.setStyleSheet("color: white;"
        #                                     "background-color: #3c3835")
        self.func_button_layout = QGridLayout()
        self.func_button_clear = QPushButton("Clear")
        self.func_button_clear.clicked.connect(self.clear_text)
        self.func_button_quit = QPushButton("Quit")
        self.func_button_quit.clicked.connect(self.exit_app)
        self.func_button_layout.addWidget(self.func_button_clear,0,0,1,1)
        self.func_button_layout.addWidget(self.func_button_quit,1,0,1,1)
        self.func_button_group.setLayout(self.func_button_layout)
        layout.addWidget(self.func_button_group,12,2,2,1)


        # selenium용 (mail, web-access) 버튼 모음 입니다.
        self.selenium_button_group = QGroupBox('ADDITIONAL FUNCTIONS')
        # self.selenium_button_group.setStyleSheet("color: white;"
        #                                 "background-color: #3c3835")
        self.selenium_button_layout = QGridLayout()
        self.selenium_button_PLM = QPushButton("PLM downloading")
        self.selenium_button_PLM.setFixedWidth(150)

        self.selenium_button_mail = QPushButton("E-mailing")
        self.selenium_button_mail.setFixedWidth(150)
        self.selenium_button_layout.addWidget(self.selenium_button_PLM,0,0,1,1)
        self.selenium_button_layout.addWidget(self.selenium_button_mail,1,0,1,1)
        self.selenium_button_group.setLayout(self.selenium_button_layout)
        layout.addWidget(self.selenium_button_group,9,2,3,1)

        self.info_group = QGroupBox('EDIT BOX - (정보 직접 기입 시, 완료 후 "update row" 버튼 클릭 필요)')
        # self.info_group.setStyleSheet("color: white;"
        #                                 "background-color: #3c3835")        
        #self.info_group = QScrollArea()
        self.info_group.setFixedWidth(400)
        self.info_layout = QGridLayout()
        self.info_le = []   # Line Editor를 많아서 List로 관리합니다. (현재 총 13개)

        self.col_list = ['구분','사양','차종','업체명','고품 회수여부','고품 접수일','고품번호','Boot','Pending','Running','주행거리.1','VIN NO','Internal\nDTC(Full)','추정 원인_진행 사항(자유 작성)','유형 분류','DTC 확인 결과\n(만도)', 'ECU_ID','분석 최종 결과']
        #self.col_list = ['구분','사양','차종','업체명','고품 회수여부','고품 접수일','고품번호','Boot','Pending','Running','주행거리.1','VIN NO','추정 원인_진행 사항(자유 작성)','유형 분류','DTC 확인 결과\n(만도)', 'ECU_ID','분석 최종 결과']
        
        
        self.info_label = self.col_list
        for idx, self.lbs in enumerate(self.info_label):
            self.info_layout.addWidget(QLabel(self.info_label[idx],self),(idx),0,1,1)
            self.info_le.append(QLineEdit())
            self.info_le[idx].setFixedHeight(20)
            self.info_layout.addWidget(self.info_le[idx],(idx),1,1,2)
        self.info_group.setLayout(self.info_layout)
        layout.addWidget(self.info_group,7,1,7,1)


        #information Control button
        self.info_button_group = QGroupBox('CONTROL_BUTTONS')

        # self.info_button_group.setStyleSheet("color: white;"
        #                                 "background-color: #3c3835")
        self.info_button_layout = QGridLayout()
        self.vin_index = QLineEdit()

        #self.vin_index.setFixedHeight(20)
        self.info_button_layout.addWidget(self.vin_index,0,0,1,2)
        self.func_button_find_vin = QPushButton("Find VIN[F6]")
        #self.func_button_find_vin = QPushButton("Find VIN NO\n[Ctrl+F]")
        self.func_button_find_vin.clicked.connect(self.find_VIN)
        #self.func_button_find_vin.setShortcut('ctrl+F')
        self.func_button_find_vin.setShortcut('F6')

        self.func_button_find_vin.setToolTip('VIN NO 기반으로 검색 수행')
        self.func_button_add_row = QPushButton("TBD")
        #self.func_button_add_row.clicked.connect(self.add_row)
        self.func_button_delete_row = QPushButton("TBD")
        #self.func_button_delete_row.clicked.connect(self.delete_row)
        self.func_button_update_row = QPushButton("update row")
        self.func_button_update_row.clicked.connect(self.update_row)

        
        self.info_button_layout.addWidget(self.func_button_find_vin,0,2,1,1)
        self.info_button_layout.addWidget(self.func_button_add_row,1,0,1,1)
        self.info_button_layout.addWidget(self.func_button_delete_row,1,1,1,1)
        self.info_button_layout.addWidget(self.func_button_update_row,1,2,1,1)
        self.info_button_group.setLayout(self.info_button_layout)

        layout.addWidget(self.info_button_group,7,2,2,1)
        
        # documentation button
        # 문서를 출력하기 위한 버튼 모음 입니다.
        self.doc_button_group = QGroupBox('DOCUMENTATION BUTTONS')
        # self.doc_button_group.setStyleSheet("color: white;"
        #                                 "background-color: #3c3835")
        self.doc_button_group.setFixedWidth(250)
        self.doc_button_layout = QVBoxLayout()
        self.doc_button = []    # Documentation 을 위한 버튼을 List로 관리합니다. 앞으로 많아질 것같아서... (현재 총 11개)
        self.doc_button_name = ['Select FA list','Fix/Release FA Report Template','TBD','Capture Screen','TBD',
                                'TBD','TBD','Fix Diagnostic Position [F2]','Save Diags [F3]','Write FA report [F4]', 'Save Diags && Write FA report [F5]']
        
        for idx, self.doc_button_name in enumerate(self.doc_button_name):
            self.doc_button.append(QPushButton(self.doc_button_name))
            self.doc_button[idx].setFixedHeight(32)
            self.doc_button_layout.addWidget(self.doc_button[idx])

        self.doc_button[0].clicked.connect(self.select_FA_list)
        self.doc_button[1].clicked.connect(self.fix_FA_Report_Templete)
        self.doc_button[3].clicked.connect(self.tool_capture)
        #self.doc_button[2].clicked.connect(self.internal_errors_capture)
        self.doc_button[7].clicked.connect(self.diag_position_set)
        self.doc_button[7].setShortcut('F2')
        self.doc_button[8].clicked.connect(self.save_diagnostics)
        self.doc_button[8].setShortcut('F3')
        self.doc_button[9].clicked.connect(self.doc_FA_report_build)
        self.doc_button[9].setShortcut('F4')
        self.doc_button[10].clicked.connect(self.one_shot)
        self.doc_button[10].setShortcut('F5')
        self.doc_button_group.setLayout(self.doc_button_layout)
        layout.addWidget(self.doc_button_group,7,3,7,1)

        # data table
        # Data들을 관리하기 위한 테이블 입니다. (DB 관리용)
        # 여기 Table이 Pandas와 연동이 되어 있습니다.
        self.data_table_group = QGroupBox('DATA TABLE')
        #self.data_table_group.setStyleSheet("color: white;"
        #                                "background-color: #3c3835")
        self.data_table_layout = QVBoxLayout()
        self.data_table_pjt = QTableWidget(self)
        
        #self.data_table_pjt.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents) ### 해당 열에 의해서 columns의 내용의 길이로 columns 크기 조절
        self.data_table_pjt.resizeRowsToContents()
        self.data_table_pjt.resizeColumnsToContents()
        self.data_table_pjt.setColumnWidth(5,100)
        self.data_table_pjt.setColumnWidth(12,200)
        self.data_table_pjt.setColumnWidth(16,200)
        
        #self.data_table_pjt.setColumnWidth(11,5)


        self.data_table_pjt.itemClicked.connect(self.item_clicked)
        self.data_table_pjt.itemActivated.connect(self.item_clicked)
        self.data_table_pjt.itemSelectionChanged.connect(self.item_clicked)
        self.data_table_layout.addWidget(self.data_table_pjt)
        self.data_table_group.setLayout(self.data_table_layout)
        
        layout.addWidget(self.data_table_group,1,0,6,4)
        
        #self.df = pd.read_excel(self.FA_list_name,  sheet_name = "Total", engine='openpyxl')
        # print('here')
        # print(self.FA_list_name)
        self.df = self.excel_to_pd(FA_list_name,  sheet_name = "Total")

        try:

            self.df['고품 접수일'] = pd.to_datetime(self.df['고품 접수일'], format='%Y%m%d')
            self.df = self.df.drop("Unnamed: 0",axis=1)
        
        except:
            pass

        self.df_raw = self.df.copy()

        print(self.df.columns)
        self.df = self.df[self.col_list]
        
        # table의 Row, Column, Header Label을 셋업 해줍니다.

        #self.df
        self.data_table_pjt.setRowCount(len(self.df.index))
        self.data_table_pjt.setColumnCount(len(self.df.columns))
        self.data_table_pjt.setHorizontalHeaderLabels(self.df.columns)

        for i in range(len(self.df.index)):
            for j in range(len(self.df.columns)):
                self.data_table_pjt.setItem(i, j, QTableWidgetItem(str(self.df.iloc[i, j])))

        
        self.data_table_pjt.resizeRowsToContents()
        self.data_table_pjt.resizeColumnsToContents()
        self.data_table_pjt.setColumnWidth(5,100)
        self.data_table_pjt.setColumnWidth(12,200)
        self.data_table_pjt.setColumnWidth(16,200)
        
        #self.data_table_pjt.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        
        self.statusbar = QStatusBar(self)
        self.statusbar.showMessage('Ready')
        self.statusbar.setFixedHeight(20)
        layout.addWidget(self.statusbar,14,0,1,1)

        # GUI 
        # 세팅을 끝내고 뿌려줍니다...
        self.setGeometry(30, 50, 800, 800)
        self.setWindowTitle("Failure Analyzer")
        self.setLayout(layout)
        #self.show()
        self.showMaximized()

        #self.showFullScreen()

    # 터미널 창을 깨끗하게...
    def clear_text(self):
        self.terminal_browser.clear()

    # 끌 때 잘 꺼지라고... 버튼 하나 놔봤어요. (근데 보통 X 누릅니다.)
    def exit_app(self):
        QCoreApplication.instance().quit()
        sys.exit(app.exec_())

    # Table (DB)에 열을 추가 합니다. 추가할 때 Line Editor의 값들을 가져 옵니다.
    # Dataframe의 값을 먼저 업데이트하고... Table Widget에 값을 뿌려줍니다.
    # 그리고 CSV 파일도 업데이트 합니다.

    def add_row(self):
        new_pjt_info = [(le.text() for le in self.info_le)]
        dfNew = pd.DataFrame(new_pjt_info, columns = self.df.columns)
        self.df = self.df.append(dfNew, ignore_index=True)
        self.data_table_pjt.setRowCount(len(self.df.index))
        self.data_table_pjt.setColumnCount(len(self.df.columns))

        for i in range(len(self.df.index)):
            for j in range(len(self.df.columns)):
                self.data_table_pjt.setItem(i, j, QTableWidgetItem(str(self.df.iloc[i, j])))
        
        #self.df = pd.DataFrame([[1,1,1,1,1,1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2,2,2,2,2,2],[3,3,3,3,3,3,3,3,3,3,3,3,3]],columns=self.info_label)
        self.df.to_csv('test.csv',encoding='utf-8-sig')
        self.data_table_pjt.resizeRowsToContents()
        self.data_table_pjt.resizeColumnsToContents()

        self.terminal_browser.append("New pjt info. added")
        for le in self.info_le:
            le.clear()

        print(self.df)
    # Table (DB)에 열을 삭제 합니다. 추가할 때 Line Editor의 값들을 가져 옵니다.
    # Dataframe의 값을 먼저 업데이트하고... Table Widget에 값을 뿌려줍니다.
    # 그리고 CSV 파일도 업데이트 합니다.

    def delete_row(self):
        self.terminal_browser.append("Row["+str(self.data_table_pjt.currentRow()+1)+ "] Deleted")
        self.df = self.df.drop(self.data_table_pjt.currentRow())
        self.df = self.df.reset_index(drop=True)
        self.data_table_pjt.setRowCount(len(self.df.index))
        self.data_table_pjt.setColumnCount(len(self.df.columns))
        for i in range(len(self.df.index)):
            for j in range(len(self.df.columns)):
                self.data_table_pjt.setItem(i, j, QTableWidgetItem(str(self.df.iloc[i, j])))
        self.df.to_csv('test.csv',encoding='utf-8-sig')
        self.data_table_pjt.resizeRowsToContents()
        self.data_table_pjt.resizeColumnsToContents()
        print(self.df)

    # Table (DB)에 열을 선하면 내용을 Line Editor에 뿌려 줍니다.
    def item_clicked(self):
        
        self.data_table_pjt.selectRow(self.data_table_pjt.currentRow())

        for i, le in enumerate(self.info_le):
            le.setText(self.data_table_pjt.item(self.data_table_pjt.currentRow(),i).text())
        
        


    # VIN NO를 검색하여 DATA TABLE에 선택합니다.

    #############################################
    ## bug>1 011052에 대한 VIN NO 찾기 불가함?? ##
    #############################################

    def find_VIN(self):

        vin_iloc = list(self.df[self.df['VIN NO'].str.contains(self.vin_index.text())]['VIN NO'].index)
        
        if len(vin_iloc) > 1:

            #QMessageBox.about(self, "Warning", f"VIN No가 여러개 존재 {vin_iloc+1}")
            QMessageBox.about(self, "Warning", f"VIN No가 여러개 존재: {list(vin_iloc + np.ones_like(vin_iloc))}번 고품")

        elif len(vin_iloc) == 1:

            self.data_table_pjt.selectRow(vin_iloc[0])
            
            for i, le in enumerate(self.info_le):
                le.setText(self.data_table_pjt.item(self.data_table_pjt.currentRow(),i).text())
            print(self.df)

        else:

            QMessageBox.about(self, "Warning", f"VIN No가 존재하지 않음")

    # Table Widget (DB) 의 선택된 행을 업데이트 합니다.
    # 업데이트 기준은 Line Editor 입니다.

    def update_row(self):

        if self.info_le[1].text():

            for i, col_ in enumerate(list(self.df.columns)):

                self.df.iloc[self.data_table_pjt.currentRow(), i] = self.info_le[i].text()
                self.data_table_pjt.setItem(self.data_table_pjt.currentRow(), i, QTableWidgetItem(str(self.df.iloc[self.data_table_pjt.currentRow(), i])))
                index_ = self.df.index[self.data_table_pjt.currentRow()]
                
                self.df_raw.loc[index_,col_] = self.df.loc[index_, col_]


            try:
                self.df_raw.to_excel(self.FA_list_name, sheet_name = "Total", index=False)
                #self.df.to_excel(self.FA_list_name, sheet_name = "Total", index=False)
            
            except Exception as e:
                QMessageBox.about(self, "Warning", f'에러 발생 : {e}, 파일 close 후 다시 실행하세요')
                traceback.print_exc()
                return

            self.data_table_pjt.resizeRowsToContents()
            self.data_table_pjt.resizeColumnsToContents()
            self.data_table_pjt.setColumnWidth(5,100)
            self.data_table_pjt.setColumnWidth(12,200)
            self.data_table_pjt.setColumnWidth(16,200)

            self.terminal_browser.append("New pjt info. updated")

            for le in self.info_le:
                le.clear()

            self.vin_index.clear()

        else:
            QMessageBox.about(self, "Warning", '업데이트할 내용이 없습니다.')


    def update_all(self):

        if self.info_le[1].text():

            for i in range(len(self.df.columns)):
                print(self.info_le[i].text())

                self.df.iloc[self.data_table_pjt.currentRow(), i] = self.info_le[i].text()

            self.data_table_pjt.setRowCount(len(self.df.index))
            self.data_table_pjt.setColumnCount(len(self.df.columns))

            for i in range(len(self.df.index)):
                for j in range(len(self.df.columns)):
                    self.data_table_pjt.setItem(i, j, QTableWidgetItem(str(self.df.iloc[i, j])))


            ## df 기준으로 df_raw를 업데이트

            for i in list(self.df.index):
                for j in list(self.df.columns):
                    self.df_raw.loc[i, j] = self.df.loc[i, j]

            try:
                self.df_raw.to_excel(self.FA_list_name, sheet_name = "Total", index=False)
                #self.df.to_excel(self.FA_list_name, sheet_name = "Total", index=False)
            
            except Exception as e:
                QMessageBox.about(self, "Warning", f'에러 발생 : {e}, 파일 close 후 다시 실행하세요')
                traceback.print_exc()
                return

            self.data_table_pjt.resizeRowsToContents()
            self.data_table_pjt.resizeColumnsToContents()
            self.data_table_pjt.setColumnWidth(5,100)
            self.data_table_pjt.setColumnWidth(12,200)
            self.data_table_pjt.setColumnWidth(16,200)

            self.terminal_browser.append("All pjt info. updated")

            for le in self.info_le:
                le.clear()

            print(self.df)

        else:
            QMessageBox.about(self, "Warning", '업데이트할 내용이 없습니다.')
        

    
    # X 버튼을 눌렀을 때 ...
    def closeEvent(self, event):
        QCoreApplication.instance().quit()
        sys.exit(app.exec_())


    def set_file_name(self, raw=0):

        ## 확장자 분류가 필요한 경우 확장 필요 ##
        ## @@ build file I/O function by regular expression
        
        # _, file_extension = os.path.splitext(full_file_name)
        # #filename, file_extension = os.path.splitext(full_file_name[0])
        # #filename = os.path.basename(full_file_name)
        # RE_rule = re.compile('^.[a-z]+', re.I) ##@@ re.I (대소문자 무시)
        # file_extension_ = RE_rule.search(file_extension)
        # file_extension_ = file_extension_.group()


        result_strs = ''

        for idx, _ in enumerate(str(self.info_le[-1].text()).split(',')):
            message = str(self.info_le[-1].text()).split(',')[idx].replace("'","").replace(" ","") + '_' + str(self.info_le[-4].text()).split(',')[idx].replace("'","").replace(" ","") + "_"
            result_strs += message
        
        if raw == 0:

            file_lists = os.listdir(result_path)
            file_lists_ = pd.DataFrame(file_lists, columns=['lists'])
            screen_mask = self.info_le[11].text()[-6:]
            file_index_ = list(file_lists_[file_lists_['lists'].str.contains(screen_mask)].index)

            for i in file_index_:
    
                file_name = file_lists_.iloc[i]['lists']
                file_name = os.path.join(result_path,file_name)
                os.remove(file_name)

            write_file_name = result_path + self.info_le[6].text().replace('/','') + '_' + self.info_le[1].text() + '_' + self.info_le[11].text()[-6:] + '_' + self.info_le[3].text() + '_'+ result_strs + self.info_le[5].text()[:10] + '.xlsx'


        elif raw == 1:
            
            working_path = result_path + r'diagnostics/'
            file_lists = os.listdir(working_path)
            file_lists_ = pd.DataFrame(file_lists, columns=['lists'])
            screen_mask = self.info_le[11].text()[-6:]
            file_index_ = list(file_lists_[file_lists_['lists'].str.contains(screen_mask)].index)

            for i in file_index_:
    
                file_name = file_lists_.iloc[i]['lists']
                file_name = os.path.join(working_path,file_name)
                os.remove(file_name)

            write_file_name = result_path + r'diagnostics/raw_'+ self.info_le[6].text().replace('/','') + '_' + self.info_le[1].text() + '_' + self.info_le[11].text()[-6:] + '_' + self.info_le[3].text() + '_'+ result_strs + self.info_le[5].text()[:10] + '.xlsx'

        return write_file_name
        

    def open_file(self):

        QMessageBox.about(self, "Warning", '주의사항: 파일 생성 전, 생성할 고품 선택 필수')
        fname = QFileDialog.getOpenFileName(self, 'Open file', self.template_path)

        return fname

    def fix_FA_Report_Templete(self):

        reply = QMessageBox.question(self, "Question", "FA report Template을 고정하시겠습니까? (Yes:고정 / No:고정해지)", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:

            fname = QFileDialog.getOpenFileName(self, 'Open file', self.template_path)
        
            if fname[0]:
                self.fixed_FA_report_template = fname[0]
                QMessageBox.about(self, "Warning", 'FA_Report_Templete이 고정되었습니다. \nSave Diag & Report 버튼 적용 시에 Template 자동 적용 됩니다!')

            else:
                QMessageBox.about(self, "Warning", 'FA_Report_Templete을 선택하세요')
                return

        else:

            try:
                self.fixed_FA_report_template = ''

            except:
                return
        

    def insert_image(self, load_wb, sheet_name, anchor, target_width, image_type):
        
        working_sheet = load_wb[sheet_name]
        file_name = self.info_le[11].text()[-6:] + image_type   ## {VIN 정보}_{image_type}
        # print(file_name)
        file_path = os.path.join(captured_image_path,file_name)
        print(file_path)
        

        if os.path.isfile(file_path):

            img = openpyxl.drawing.image.Image(file_path)
            scaller = img.width/target_width
            img.height = img.height / scaller
            img.width = target_width
            img.anchor = anchor
            
            working_sheet.add_image(img)
            print('화면 이미지 추가 완료')

            return load_wb
                
        else:
            QMessageBox.about(self, "Warning", '저장된 캡쳐 파일이 없습니다.')
            return load_wb
            
   
    def one_shot(self):

        if not(self.fixed_FA_report_template):
            self.fix_FA_Report_Templete()
                    
        result_ = self.save_diagnostics(guide= False)

        if result_ == 'okay':
            self.doc_FA_report_build(fixed_template = True)

        else:
            return


    # FA List 검색 버튼을 눌렀을 때...
    def select_FA_list(self):

        fname = self.open_file()

        if bool(fname[0]):
            self.FA_list_name = fname[0]
            self.terminal_browser.append(str(fname[0]))
            #self.df = pd.read_excel(self.FA_list_name,  sheet_name = "Total", engine='openpyxl')
            self.df = self.excel_to_pd(self.FA_list_name,  sheet_name = "Total")


            try:
                self.df = self.df.drop("Unnamed: 0",axis=1)
                
            except:
                pass

            self.df_raw = self.df.copy()

            print(self.df.columns)
            self.df = self.df[self.col_list]

            self.update_all()

            ### Config 상에 FA_list 위치 변경 ###
            config_name = r'.\config\overall_config.xlsx'

            load_wb = load_workbook(config_name, data_only=False) #### data_only=False for excel formulation
            sheet_name = "Total"
            load_ws = load_wb[sheet_name]


            for row in range(2,50):

                if load_ws.cell(row=row,column=1).value == 'FA_list_name':
                    load_ws.cell(row=row,column=2).value = self.FA_list_name
                    load_ws.cell(row=row,column=5).value = self.FA_list_name
                    
                    break
                    

            load_wb.save(config_name)

            ##############

        
        else:
            QMessageBox.about(self, "Warning", 'FA_list를 선택하세요')
            return

    def diag_position_set(self):
        
        reply = QMessageBox.question(self, "Question", "Data table에서 적용할 제품을 선택하셨나요?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:

            
            load_wb = load_workbook(self.diagnostic_list_name, data_only=False) #### data_only=False for excel formulation
            sheet_name = self.info_le[1].text()[:5]
            load_ws = load_wb[sheet_name]


            for row in range(2,50):

                if load_ws.cell(row=row,column=1).value != None:

                    location = load_ws.cell(row=row,column=1).value
                    position_origin = ()

                    if location in ['Start_diag','CAN_Command','CAN_log']:
                        msg = f'{location}에서 마우스를 좌 클릭해주세요'
                    
                    elif location in ['Read_DTC','Internal_Test'] and self.info_le[1].text()[:5] == 'FCM30':
                        msg = f'"Function" Tab의 {location}에서 마우스를 좌 클릭해주세요'
                        QMessageBox.about(self, "Warning", msg)

                        position_origin = qd_event.get_mouse_location()

                        msg = f'{location}의 "Copy" 버튼 에서 마우스를 좌 클릭해주세요'

                    
                    else:
                        msg = f'{location}의 "Copy" 버튼 에서 마우스를 좌 클릭해주세요'

                    QMessageBox.about(self, "Warning", msg)

                    position = qd_event.get_mouse_location()

                    load_ws.cell(row=row,column=2).value = str(position[0])
                    load_ws.cell(row=row,column=3).value = str(position[1])

                    if position_origin:

                        load_ws.cell(row=row,column=2).value = str(load_ws.cell(row=row,column=2).value)+','+ str(position_origin[0])
                        load_ws.cell(row=row,column=3).value = str(load_ws.cell(row=row,column=3).value)+','+ str(position_origin[1])

                    
                    time.sleep(0.1)


                else:
                    load_ws.delete_rows(row,3)

                    break

            load_wb.save(self.diagnostic_list_name)

            msg = f'항목별 마우스 좌표 추출이 완료되었습니다. Save Diag를 진행하세요!'
            QMessageBox.about(self, "Warning", msg)

        else:

            return

    def tool_capture(self):
        
        QMessageBox.about(self, "Warning", "캡쳐할 화면에서 마우스 좌클릭 하세요")

        # (x,y) = qd_event.get_mouse_location()
        # self.mouse_click(x,y)
        # time.sleep(0.1)

        self.capture_screen()

        QMessageBox.about(self, "Warning", "캡쳐가 수정 되었습니다.")

    def capture_screen(self):

        time.sleep(0.5)

        img = ImageGrab.grab()
        vin = self.info_le[11].text()[-6:]
        f_name = f'{captured_image_path}{vin}_contents.png'
        img.save(f_name)
        
        time.sleep(0.5)


    def save_diagnostics(self, guide=True):

        reply = QMessageBox.question(self, "Question", "Data table에서 적용할 차종 선택하셨나요? 매크로 동작 중에 마우스 조작 금지!", QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply == QMessageBox.Yes:

            try:
            #if True:

                ##########################################################
                ## 툴 브레이크 확인 및 raw data 저장 ##

                tool_brake_id = win32gui.GetForegroundWindow()
                print('tool_brake_id : ', tool_brake_id)
                win32gui.SetForegroundWindow(tool_brake_id)

                #df_diag = pd.read_excel('get_diagnostics.xlsx', sheet_name = self.info_le[1].text(), engine='openpyxl')
                df_diag = self.excel_to_pd(self.diagnostic_list_name, sheet_name = self.info_le[1].text()[:5])
                df_diag.set_index('items', inplace=True)
                df_diag_index = list(df_diag.index)

                if self.info_le[1].text()[:5] == 'FCM30':

                    df_diag_projects = self.excel_to_pd('.\config\Specific_Project_diag.xlsx', sheet_name = self.info_le[1].text()[:5])
                    df_diag_projects.set_index('group', inplace=True)
                    #df_diag_projects_index = list(df_diag_projects.index)

                    project_name = self.info_le[2].text().replace(" ","")
                    project_name_locs = list(df_diag_projects[df_diag_projects['Project'].str.contains(project_name)]['Project'].index)

                    try:
                        for project_name_loc in project_name_locs:
                    
                            dtc_type = df_diag_projects.loc[project_name_loc,'dtc']
                            internal_type = df_diag_projects.loc[project_name_loc,'internal']
                            self.internal_type = internal_type
                        
                    except Exception as e:
                        QMessageBox.about(self, "Warning", f'에러 발생 : {e}, FCM30 차종이 "FCM_Gen3.0_diag.xlsx"에 있는지 확인하세요')
                        traceback.print_exc()

                x = int(df_diag.loc['CAN_log', 'coordinate_x'])
                y = int(df_diag.loc['CAN_log', 'coordinate_y'])

                ## 0. FCM30의 경우는 다양한 READ DTC / Internal Error를 선택하기 위해서 Tool 상에서 해당 선별가능하도록 *_origin 추출


                ## 1. CAN_log clear ##

                self.mouse_click(x,y)
                time.sleep(0.1)
                self.mouse_click_right(x,y)
                time.sleep(0.2)
                self.mouse_click(x+20,y+10)
                time.sleep(0.2)


                ## 2. raw_data 저장 ##
                for i in df_diag_index:
                
                    x = int(str(df_diag.loc[i, 'coordinate_x']).split(',')[0])
                    y = int(str(df_diag.loc[i, 'coordinate_y']).split(',')[0])

                    
                    try:
                        x_origin = int(str(df_diag.loc[i, 'coordinate_x']).split(',')[1])
                        y_origin = int(str(df_diag.loc[i, 'coordinate_y']).split(',')[1])

                    except:
                        pass

                    if i == 'Start_diag':
                        
                        ## 휠 스크롤로 정 위치 찾기
                        self.scroll(clicks=80, delta_x = x, delta_y= y, delay_between_ticks=0.01)
                        
                        self.mouse_click(x,y)
                        self.mouse_click(x,y)
                        time.sleep(1)
                        continue

                    #### FCM30의 Read DTC는 차종 정보에 따라서 이동 ###
                    elif i == 'Read_DTC' and self.info_le[1].text()[:5] == 'FCM30':
    
                        if dtc_type == 'FD':
                            y_origin = y_origin + 20

                        time.sleep(0.1)
                        self.mouse_click(x_origin,y_origin)
                        time.sleep(0.1)
                        self.mouse_click(x_origin,y_origin)
                        time.sleep(0.2)


                    #### FCM30의 Internal Test는 차종 정보에 따라서 이동 ###
                    elif i == 'Internal_Test' and self.info_le[1].text()[:5] == 'FCM30':

                        if internal_type == 'FD':
                            y_origin = y_origin + 20

                        elif internal_type == 'CP':
                            y_origin = y_origin + 40

                        time.sleep(0.5)
                        self.mouse_click(x_origin,y_origin)
                        time.sleep(0.5)
                        self.mouse_click(x_origin,y_origin)
                        time.sleep(0.5)


                    time.sleep(0.1)
                    self.mouse_click(x,y)

                    ## F9 눌러서 Get 으로 read 수행        
                    self.shell.SendKeys("{F9}")

                    time.sleep(0.5)
                    if i == 'Internal_Test':
                        time.sleep(0.5)
                    
                    ## "copy"를 클릭해서 clipboard에 저장

                    self.mouse_click(x,y)
                    time.sleep(0.1)


                    ## Case에 따라 다른 행동 수행 ##
                    # Internal Test capture #
                    
                    if i == 'Internal_Test':
                        
                        time.sleep(0.5)
                        self.mouse_click(x,y)
                        time.sleep(0.5)
                        self.internal_errors_capture()

                    # CAN_log 추출  #
                    elif i == 'CAN_log':
                        
                        self.mouse_click_right(x,y)
                        time.sleep(0.1)

                        self.mouse_click(x+40,y+42)
                        time.sleep(0.1)

                    else:
                        pass

                    ## 획득한 diag 정보를 dataframe에 저장 ##
                    try:
                        df_diag.loc[i, 'raw_info'] = pc.paste()
                        time.sleep(0.1)
                        
                    except:
                        pass
                
                
                ### 전체 화면 capture ####
                self.capture_screen()

                ##########################################################################################
                ## raw data 저장 메세지에 대한 데이터 추출 ##
                
                ## 1. CAN message 저장 ##
                CAN_log_messages = df_diag.loc['CAN_log', 'raw_info'].decode()

                print(CAN_log_messages)
                print(type(CAN_log_messages))

                ## Diag message 추출 및 저장 ##

                for idx, i in enumerate(df_diag_index):
                
                    
                    ##### 1. READ ECU ID에 대한 parsing ###
                    if i == 'Read_ECU_ID' and df_diag.loc[i, 'raw_info']:

                        df_diag.loc[i, 'text'] = self.get_ECU_ID(str(df_diag.loc[i, 'raw_info']))
                        print(df_diag.loc[i, 'text'])

                    
                        
                    ##### 2. READ ETC에 대한 parsing ###
                    elif i == 'Read_DTC' and df_diag.loc[i, 'raw_info']:

                        #print(f'i 내용은 {i}')

                        DTC_dict = self.get_DTC_list(df_diag.loc[i, 'raw_info'])

                        ## Tool brake 상에서 확인된 전체 DTC 저장
                        df_diag.loc[i, 'text'] = str(list(DTC_dict.keys())) ## DTC 저장
                        df_diag.loc[i, 'remark'] = str(list(DTC_dict.values()))  ## 상태 기록(과거 or 현재)
                       

                    ##### 3. READ ECU ID와 READ DTC 항목을 제외한 다른 항목에 대한 Raw_info 저장 ###
                    if str(df_diag.loc[i, 'CAN_Rx']) != 'nan' and str(df_diag.loc[i, 'CAN_Rx_dummy']) != 'nan' and i != 'Internal_Test':
                        
                        raw_message, CAN_messages = self.CAN_message_getter(df_diag, i , logged_messages=CAN_log_messages)
                        df_diag.loc[i, 'raw_info'] = str(CAN_messages)
                        
                        CAN_messages = self.CAN_message_slicer(CAN_messages, df_diag, i)
                        
                        
                        try:
                            df_diag.loc[i,'text'] = CAN_messages

                        except:
                            pass

                        if i == 'Read_UART_Booting_Timeout' or i == 'Read_SPI_Booting_Timeout':  ## 없는 경우 skip
                            
                            ## Read_UART_Booting의 경우는 동일한 CAN_Rx가 4개임. 
                            ## 한번에 해당하는 것을 생성하기 위해서는 CAN 전체 로그 CAN_Tx가 포함된 다른 Log에서 pc.paste()를 수행해야 함.

                            df_diag.loc[i,'raw_info'] = str(raw_message)[2:-2]
                            CAN_messages = str(raw_message)[2:-2]
                            
                            CAN_messages = CAN_messages.replace("'",'').split(', ')
                            CAN_messages = CAN_messages[-4:]

                            for num, CAN_message in enumerate(CAN_messages):
                               
                                CAN_message = self.CAN_message_slicer(CAN_message, df_diag, i)
                                df_diag.loc[:,'text'][num+idx] = CAN_message

                    elif i == 'Internal_Test':# and (self.info_le[1].text() != 'FCM20'):

                        raw_message, CAN_messages = self.CAN_message_getter(df_diag, i , logged_messages=CAN_log_messages)
                        df_diag.loc[i, 'raw_info'] = str(CAN_messages)

                        CAN_messages = self.CAN_message_slicer(CAN_messages, df_diag, i)

                        location = self.internal_error_extractor(CAN_messages)
                        df_internal_errors_map = self.get_Internal_Error_List_df()

                        ## 발생한 Internal Erorr 추출
                        df_internal_errors_map = df_internal_errors_map.loc[location,:]
                        ## 발생한 internal Error 저장
                        df_diag.loc['Internal_Test','remark'] = str(df_internal_errors_map) 
                        ## 유효 internal Error 저장 (유효 internal Error는 error_map 상에서 list 아래에로 등장)
                        df_diag.loc['Internal_Test','text'] = str(df_internal_errors_map[df_internal_errors_map['Detection'] == 'O']['Internal Error'].to_list())


                self.update_info_le(df_diag)
                

                write_file_name = self.set_file_name(raw=1)

                try:
                    df_diag.to_excel(write_file_name, sheet_name=self.info_le[1].text()[:5])
                
                except Exception as e:
                    QMessageBox.about(self, "Warning", f'에러 발생 : {e}, 파일 close 후 다시 실행하세요')
                    traceback.print_exc()
                    return

                self.terminal_browser.append(write_file_name + " is saved")

                print(guide)

                if guide:
                    QMessageBox.about(self, "Warning", '진단 정보 획득 완료, 특이 사항이 없으면 FA report를 수행하세요')
                    traceback.print_exc()

                return 'okay'

               
            except Exception as e:
                QMessageBox.about(self, "Warning", f'에러 발생 : {e}, Save Diag를 다시 실행하세요')
                traceback.print_exc()

                return 'ng'

        else:
            return 'ng'


    # FA 보고서 만들기 버튼을 눌렀을 때...
    def doc_FA_report_build(self, fixed_template=False):

        try:

            if fixed_template == True:

                try:
                    fname = self.fixed_FA_report_template

                except Exception as e:
                    QMessageBox.about(self, "Warning", f'알맞은 option을 선택하세요. {e}')
                    traceback.print_exc()
                    return

            elif fixed_template == False:
                
                try:
                    fname = self.open_file()[0]
                    self.terminal_browser.append(str(fname))
                
                except:
                    QMessageBox.about(self, "Warning", '템플릿을 선택하세요')
                    traceback.print_exc()
                    return

            # col_list = ['구분','사양','차종','업체명','고품 회수여부','고품 접수일','고품번호','Boot','Pending','Running','주행거리.1','VIN NO','유형 분류','DTC 확인 결과\n(만도)', 'ECU_ID','분석 최종 결과']

            ## Check - sheet부분 ##
            load_wb = load_workbook(fname, data_only=False) #### data_only=False for excel formulation
            sheet_name = 'Check-sheet'

            load_ws = load_wb[sheet_name]

            load_ws['E9'] = self.info_le[11].text() #VIN
            load_ws['E10'] = self.info_le[10].text() #주행거리

            load_ws['E20'] = self.info_le[7].text() #Booting Timeout Count
            load_ws['E21'] = self.info_le[8].text() #Pending Timeout Count
            load_ws['E22'] = self.info_le[9].text() #Running Timeout Count

            load_ws['E11'] = self.info_le[-2].text() #ECU_ID
            
            try:

                load_ws['E13'] = self.info_le[-5].text().split(',')[0] #Mobile Eye Boot Version
                load_ws['E14'] = self.info_le[-5].text().split(',')[1] #Mobile Eye App Version

            except Exception as e:
                QMessageBox.about(self, "Warning", 'Mobile Eye Ver이 없습니다.')
                traceback.print_exc()

                return

            #########################################
            ##### 분기별 상이한 부분에 대한 처리 #####
            #########################################

            ## 유효한 DTC만 기록 ###
            if self.info_le[-1].text() == 'NTF':
                load_ws['E16'] = self.info_le[-1].text() #DTC_list => NTF
                
            
            else:
                load_ws['E16'] = self.info_le[-3].text() #DTC_list => DTC list
                load_ws['E17'] = self.info_le[-4].text() #DTC_hist => 과거/현재 분류


            if ('현재' not in str(self.info_le[-4].text())) and (str(self.info_le[-5].text().split(',')[1]) == '00 00 00' or str(self.info_le[-5].text().split(',')[1]) == '00 00 00 00'):
                load_ws['E18'] = '전원 인가 방치 시 재현 확인 필요' ## 약 5분 지연 시 count 증가로 인하여 DTC 발생 예정
                

            elif ('현재' not in str(self.info_le[-4].text())) and (str(self.info_le[-5].text().split(',')[1]) != '00 00 00' or str(self.info_le[-5].text().split(',')[1]) != '00 00 00 00'):
                load_ws['E18'] = '재현 평가 진행 필요'  ## 약 5분 지연 후에도 DTC 발생 여부 미정

            elif ('현재' in str(self.info_le[-4].text())):
                load_ws['E18'] = '즉시'

            #########################################
            ### Project 별 상이한 부분에 대한 처리 ###
            #########################################

            if self.info_le[1].text()[:5] != 'FCM20':
                load_ws['E19'] = self.info_le[-6].text() # Internal Error 저장 (decode가 안되는 nan의 경우는 삭제)

        
            if self.info_le[1].text()[:5] != 'FCM20':

                load_ws['E20'] = self.info_le[7].text() #UART/SPI Booting Timeout Count
                load_ws['E21'] = self.info_le[8].text() #UART/SPI Pending Timeout Count
                load_ws['E22'] = self.info_le[9].text() #UART/SPI Running Timeout Count
            
            else:
                pass


            ##@@ Image insert 부분
            try:

                load_ws = load_wb['DTC 정보']

                sheet_name = 'DTC 정보'
                anchor = 'A1'
                target_width = 1600
                image_type = '_contents.png'
                load_wb = self.insert_image(load_wb, sheet_name, anchor, target_width, image_type)

                anchor = 'A45'
                target_width = 600
                image_type = '_internal_errors.png'
                load_wb = self.insert_image(load_wb, sheet_name, anchor, target_width, image_type)
            
            except:
                print('이미지가 없습니다!')

            write_file_name = self.set_file_name()  ##@@ build file I/O function by regular expression

            try:
                load_wb.save(write_file_name)

            except Exception as e:    
                QMessageBox.about(self, "Warning", f'에러 발생 : {e}, 파일 close 후 다시 실행하세요')
                traceback.print_exc()
                return

            self.terminal_browser.append(write_file_name + " is saved")
            self.update_row()
            QMessageBox.about(self, "Warning", 'FA report를 생성 하였습니다. 다음 시료를 선택해주세요.')

        except Exception as e:    
            QMessageBox.about(self, "Warning", f'에러 발생 : {e}, 다시 진행하세요')
            traceback.print_exc()
            return
    
    def scroll(self, clicks=0, delta_x=0, delta_y=0, delay_between_ticks=0):

        if clicks > 0:
            increment = win32con.WHEEL_DELTA
        else:
            increment = win32con.WHEEL_DELTA * -1


        win32api.SetCursorPos((delta_x, delta_y))

        for _ in range(abs(clicks)):
            win32api.mouse_event(win32con.MOUSEEVENTF_WHEEL, delta_x, delta_y, increment, 0)
            time.sleep(delay_between_ticks)


    def mouse_click(self, x, y):
    
        win32api.SetCursorPos((x, y))  ## 위치로 이동
        
        time.sleep(0.05)
        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x, y, 0, 0)   ## 마우스 왼쪽 버튼 click
        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x, y, 0, 0)     ## 마우스 왼쪽 버튼 Release


    def mouse_click_right(self, x, y):
        
        win32api.SetCursorPos((x, y))  ## 위치로 이동

        time.sleep(0.1)
        win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, x, y, 0, 0)   ## 마우스 왼쪽 버튼 click
        win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, x, y, 0, 0)     ## 마우스 왼쪽 버튼 Release
    
    def internal_errors_capture(self):

        #print(captured_image_path)

        #captured_image_path = str(captured_image_path)
        #print(captured_image_path)
        
        #print(self.captured_image_path)

        captured_image_path = r'D:/RPA_FA/result/captured_image/'    ##@@ 찾고자 하는 '직접 캡쳐한' 그림파일이 들어있는 폴더

        #self.mspaint.start(cmd_line = 'C:\Windows\system32\mspaint.exe', work_dir=captured_image_path)
        self.mspaint.start(cmd_line = 'C:\Windows\system32\mspaint.exe')
        self.mspaint.connect(path = 'C:\Windows\system32\mspaint.exe')

        mspaint_window_id = win32gui.GetForegroundWindow()
        print('mspaint_window_id : ', mspaint_window_id)
        win32gui.SetForegroundWindow(mspaint_window_id)

        time.sleep(1)
        self.shell.SendKeys("^e",0)
        time.sleep(0.2)
        self.shell.SendKeys("%w",0)
        time.sleep(0.2)
        self.shell.SendKeys("100")
        time.sleep(0.2)
        self.shell.SendKeys("%h",0)
        time.sleep(0.2)
        self.shell.SendKeys("100")
        time.sleep(0.2)
        self.shell.SendKeys("{ENTER}")
        time.sleep(0.2)
        self.shell.SendKeys("^v",0)
        time.sleep(1)
        #self.shell.SendKeys("^s",0)
        self.shell.SendKeys("{F12}",0)
        time.sleep(0.5)

        vin = self.info_le[11].text()[-6:]
        
        time.sleep(0.5)
        f_name = f'{vin}_internal_errors.png'
        self.shell.SendKeys(f_name)

        time.sleep(2)
        #self.shell.SendKeys("{ENTER}")
        self.shell.SendKeys("%s",0)
        time.sleep(0.5)
        self.shell.SendKeys("y",0)
        time.sleep(2.5)
        self.shell.SendKeys("%{F4}",0)
        #self.mspaint.kill()

#############################################

    def get_ECU_ID(self, ID_string):
        
        #strings = ID_string.decode()
        #print(strings)
        strings = ID_string.split('\\r\\n')
        result = '';
        
        for string in strings:
            if string.startswith(',,'):
                result += string

        result = result.replace(',,',' ')

        print(f'result is {result}')
        
        byte_array = bytearray.fromhex(result)
        #self.ID_str = byte_array.decode()
        ID_str = byte_array.decode()

        print(f'ID_str is {ID_str}')

        return ID_str

    def get_DTC_list(self, DTC_string):
        
        DTC_string = DTC_string.decode()

        pattern_dtc = r'C[0-9A-Z]{4}' ##C****
        pattern_history = r':[0-9]{2}[)]' ## ':89)' or ':08)'

        DTC_list = re.findall(pattern_dtc, DTC_string)
        History_list = re.findall(pattern_history, DTC_string)
        History_decode = []

        for i in History_list:
            
            if i[1:-1] == '89':
                History_decode.append('현재')

            else:
                History_decode.append('과거')

        #self.DTC_dict = dict(zip(DTC_list,History_decode))
        DTC_dict = dict(zip(DTC_list,History_decode))

        return DTC_dict

    def compare_to_valid_DTC_list(self, DTC_dict):


        df_dtc = self.excel_to_pd(self.DTC_list_name,  sheet_name = self.info_le[1].text()[:5])
        df_dtc.dropna(inplace=True)
        dtc_list = df_dtc['DTC'].to_list()

        print(f'Screening DTC list : {dtc_list}')

        DTC_save = []
        History_save = []

        for DTC in list(DTC_dict.keys()):

            if DTC in dtc_list:

                DTC_save.append(DTC)
                History_save.append(DTC_dict[DTC])

        return DTC_save, History_save


    def CAN_message_slicer(self, CAN_message, df_diag, i):

        masking_message = df_diag.loc[i, 'masking messages'].split(',')
        padding_message = df_diag.loc[i, 'padding message']
        positive_response = df_diag.loc[i, 'positive response']

        for j in range(len(masking_message)):

            CAN_message = CAN_message.replace(masking_message[j],'')   ## CAN meesage slicing

            ## 양쪽 공란 있을 경우 제거
            CAN_message = str.strip(CAN_message)

            ## Padding message 제거
            while CAN_message.endswith(padding_message):
                CAN_message = CAN_message[:-2]
                CAN_message = str.strip(CAN_message)

        ## check positive response and delete it.
        if positive_response == positive_response: #nan이 아닌 경우 추줄
                    
            print(f'defined positive response is :{positive_response}')

            if CAN_message.startswith(positive_response):

                print('CAN diagnostic has positive response!!')

                CAN_message = CAN_message.replace(positive_response, '')
                CAN_message = str.strip(CAN_message)

            else:
                print('CAN diagnostic has negative response!!')

        else:

            print(f'defined positive response is none')
            pass

        return CAN_message


    def CAN_message_getter(self, df_diag, i , logged_messages):
        
        RX_messages = df_diag.loc[i, 'CAN_Rx']
        RX_message_spacers = df_diag.loc[i, 'CAN_Rx_dummy']
        
        RX_messages = RX_messages.split(',')
        RX_message_spacers = RX_message_spacers.split(',')

        scan_position = 0
        raw_message = []

        for j in range(len(RX_messages)):

            check_msg = str(RX_messages[j]) + str(RX_message_spacers[j])
            print(check_msg)
            print(type(check_msg))
            
            iterations = re.finditer(check_msg, logged_messages)

            print(f'iterations: {iterations}')
            print(type(iterations))
            
            for idx, iteration in enumerate(iterations):

                if (scan_position < iteration.start()) and (j ==0):
                    
                    last_messages_list = str.strip(iteration.group())
                    scan_position = iteration.start()

                elif scan_position < iteration.start() and (j > 0):

                    last_messages_list += str.strip(iteration.group())
                    scan_position = iteration.start()

                raw_message.append(iteration.group())
                CAN_messages = last_messages_list

                print(f'before_raw_info: {raw_message}')
                print(f'before_CAN_messages: {CAN_messages}')


        return raw_message, CAN_messages


    def internal_error_extractor(self, CAN_messages):
    
        
        ### // 메세지 관련 부분 확인 필요 // ##
        ##### CAN_log 중에 Internal Error 관련된 부분 추출하는 코드 #####
        ##### 맨 마지막의 UDS 기준의 메세지들을 추출 ####

        CAN_messages = CAN_messages.replace("' ","").replace(",","").replace("'","")

        print(CAN_messages)
        internal_messages_list = CAN_messages.split(' ')

        ## Internal error flag indexing 및 reversing ## 
        ## 파이썬 진수 변환 https://blockdmask.tistory.com/433 ###

        error_flag_index =[]

        for index_byte, internal_messsage in enumerate(internal_messages_list):

            print(f'index_byte: {index_byte}')
            print(f'Error flag: {internal_messsage}')

            internal_errors_binary = bin(int(internal_messsage,16))[2:].zfill(8)
            print(internal_errors_binary)
            internal_errors_binary_reversed = internal_errors_binary[::-1]   ## 이 상태로 비교

            print(internal_errors_binary_reversed)

            for index_bit, internal_error in enumerate(internal_errors_binary_reversed):


                if not(bool(int(internal_error))):

                    error_flag_index.append((index_byte+1,index_bit))

        return error_flag_index


    def get_Internal_Error_List_df(self):
    
        if self.info_le[1].text()[:5] == "FCM30":
            df_inter_erros_map = self.excel_to_pd(self.internal_error_list_name, sheet_name = self.info_le[1].text()[:5]+'_'+self.internal_type)

        else:
            df_inter_erros_map = self.excel_to_pd(self.internal_error_list_name, sheet_name = self.info_le[1].text()[:5])

        cols = ['No.','bit','Sub_group', 'Internal Error', 'Causes','Detection']
        df_inter_erros_map = df_inter_erros_map[cols]
        df_inter_erros_map.set_index(['No.','bit'], inplace=True) ## No.와 bit column으로 multi index 설정
        #df_inter_erros_map.index                                 ## dataframe의 index 확인 tuple 형태로 index 설정됨 eg> (1,0),... (64,7)

        return df_inter_erros_map


    def update_info_le(self, df_diag):
                
        ## info_le 상에 필요 부분 업데이트

        #################
        ## ECU ID update ##
        self.info_le[-2].setText(df_diag.loc['Read_ECU_ID', 'text'])

        #################
        ## 유효 DTC List update (EXCEL sheet 상에서 DTC list 불러오고 관리하는 유효 DTC만 저장) ###
        DTC_dict = dict(zip(df_diag.loc['Read_DTC', 'text'][2:-2].replace("'","").split(', '),df_diag.loc['Read_DTC', 'remark'][2:-2].replace("'","").split(', ')))
        effect_dtc, effect_dtc_state = self.compare_to_valid_DTC_list(DTC_dict)

        self.info_le[-3].setText(str(effect_dtc)[2:-2].replace("'",""))
        self.info_le[-4].setText(str(effect_dtc_state)[2:-2].replace("'",""))

        #########################
        ## Mobileye 관련 정보 update
        self.info_le[-5].setText(df_diag.loc['Read_Mobileye_Boot', 'text'] + ',' + df_diag.loc['Read_Mobileye_App', 'text'] + ',' + df_diag.loc['Read_AppMainState', 'text'])

        #########################
        ### UART BOOTING count update (FCM20 해당 없음) ####
        
        if self.info_le[1].text()[:5] == 'FCM25':   ## 앞에 2byte 추출

            self.info_le[7].setText(df_diag.loc['Read_UART_Booting_Timeout', 'text'][:2])
            self.info_le[8].setText(df_diag.loc['Read_UART_Pending_Timeout', 'text'][:2])
            self.info_le[9].setText(df_diag.loc['Read_UART_Running_Timeout', 'text'][:2])

        elif self.info_le[1].text()[:5] == 'FCM30': ## 뒤에 2byte 추출

            self.info_le[7].setText(df_diag.loc['Read_SPI_Booting_Timeout', 'text'][-2:])
            self.info_le[8].setText(df_diag.loc['Read_SPI_Pending_Timeout', 'text'][-2:])
            self.info_le[9].setText(df_diag.loc['Read_SPI_Running_Timeout', 'text'][-2:])


        #######################
        ### Internal Error 관련 update (FCM20 해당 없음 / FCM30: 3종류)####

        if self.info_le[1].text()[:5] != 'FCM20':

            internal_errors = df_diag.loc['Internal_Test','text'].replace('[','').replace(']','').replace("'",'').replace(', nan','')
            self.info_le[-6].setText(internal_errors)

        ########################
        ## 최종 결과 update (유효 DTC 및 결과에 따라 최종 결과로 저장 [FCM25])##

        Read_Mobileye_App = df_diag.loc['Read_Mobileye_App', 'text']
        Read_AppMainState = df_diag.loc['Read_AppMainState', 'text']

        ### Case#1 :DTC 확인 결과가 있는 경우
        if self.info_le[-3].text():
            self.info_le[-1].setText(self.info_le[-3].text())
        
        ### Case#2 :DTC 확인 결과가 없고 Mobileye_App가 '00 00 00' 인 경우
        elif self.info_le[-3].text() == '' and not(Read_Mobileye_App == '00 00 00' or Read_Mobileye_App == '00 00 00 00'):
            self.info_le[-1].setText('NTF')

        ### Case#3 :DTC 확인 결과가 없고 Mobileye_App가 '00 00 00' 이지만 AppMainState가 'AC'경우
        elif self.info_le[-3].text() == '' and (Read_Mobileye_App == '00 00 00' or Read_Mobileye_App == '00 00 00 00') and (Read_AppMainState == 'AC'):
            self.info_le[-1].setText('NTF')

        ### Case#3 :DTC 확인 결과가 없고 Mobileye_App가 '00 00 00' 이고 AppMainState도 'AC'가 아닌 경우 => 5분뒤 DTC 발생 예정
        elif self.info_le[-3].text() == '' and (Read_Mobileye_App == '00 00 00'  or Read_Mobileye_App == '00 00 00 00') and not(Read_AppMainState == 'AC'):
            self.info_le[-1].setText('(C1604-C1606)')
        
        else:
            print('something wrong')


    def excel_to_pd(self, file_name, sheet_name):

        data_frame = pd.read_excel(file_name, sheet_name=sheet_name, engine='openpyxl')

        return data_frame


#############################################

# 1. start diag_wheel up 넣기 (Done)
# 2. Save diag 함수 sub 함수 단위로 쪼개기 (Done)
# 3. 저장 상에 오래 걸리는 이유 확인 및 해결 (Done)

#############################################

if __name__ == "__main__":
    app = QApplication.instance()
    if app is None:
        app = QApplication(sys.argv)
    window = MyWindow()
    window.show()
    app.exec_()
    sys.exit(app.exec_())